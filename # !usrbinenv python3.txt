# !/usr/bin/env python3
# Generated by Proteus Visual Designer for Raspberry Pi

# Modules
from goto import with_goto
from stddef import *
import var
import pio
import resource
from datetime import datetime
import RPi.GPIO as GPIO
import time
from mpu6050 import mpu6050

class MotorController:
    def __init__(self, pwm_pin, in1_pin, in2_pin, in3_pin=None, in4_pin=None, in5_pin=None, in6_pin=None):
        self.pwm_pin = pwm_pin
        self.in1_pin = in1_pin
        self.in2_pin = in2_pin
        self.in3_pin = in3_pin
        self.in4_pin = in4_pin
        self.in5_pin = in5_pin
        self.in6_pin = in6_pin
        
        self.motor_direction = False  # True for one direction, False for the other

        GPIO.setup(self.pwm_pin, GPIO.OUT)
        if self.in1_pin is not None:
            GPIO.setup(self.in1_pin, GPIO.OUT)
        if self.in2_pin is not None:
            GPIO.setup(self.in2_pin, GPIO.OUT)
        if self.in3_pin is not None:
            GPIO.setup(self.in3_pin, GPIO.OUT)
        if self.in4_pin is not None:
            GPIO.setup(self.in4_pin, GPIO.OUT)
        if self.in5_pin is not None:
            GPIO.setup(self.in5_pin, GPIO.OUT)
        if self.in6_pin is not None:
            GPIO.setup(self.in6_pin, GPIO.OUT)

        self.pwm = GPIO.PWM(self.pwm_pin, 1000)
        self.pwm.start(0)

    def move(self, speed=100):
        if self.in1_pin is not None:
            GPIO.output(self.in1_pin, GPIO.HIGH)
        if self.in2_pin is not None:
            GPIO.output(self.in2_pin, GPIO.LOW)
        if self.in3_pin is not None:
            GPIO.output(self.in3_pin, GPIO.HIGH)
        if self.in4_pin is not None:
            GPIO.output(self.in4_pin, GPIO.LOW)
        if self.in5_pin is not None:
            GPIO.output(self.in5_pin, GPIO.HIGH)
        if self.in6_pin is not None:
            GPIO.output(self.in6_pin, GPIO.LOW)
        
        self.pwm.ChangeDutyCycle(speed)

    def stop(self):
        self.pwm.stop()
        GPIO.cleanup()

class MotorSystem:
    def __init__(self):
        self.ZN_AXIS_MOTORS = MotorController(26, 22, 23, 25, 24)
        self.YN_AXIS_MOTORS = MotorController(21, 18, 27, 4, 17)
        self.XN_AXIS_MOTORS = MotorController(21, 27, 18)
        
        self.ZP_AXIS_MOTORS = MotorController(26, 23, 22, 24, 25)
        self.YP_AXIS_MOTORS = MotorController(21, 27, 18, 17, 4)
        self.XP_AXIS_MOTORS = MotorController(21, 17, 4)
        
        self.UP_DIRECTION_PIN = 6  # GO UP
        self.DOWN_DIRECTION_PIN = 5   # GO DOWN
        self.LEFT_DIRECTION_PIN = 20   # GO LEFT
        self.RIGHT_DIRECTION_PIN = 19  # GO RIGHT
        self.FORWARD_DIRECTION_PIN = 16  # GO FORWARD
        self.BACK_DIRECTION_PIN = 13  # REVERSE

        GPIO.setup(self.UP_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.setup(self.DOWN_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.setup(self.LEFT_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.setup(self.RIGHT_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.setup(self.FORWARD_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
        GPIO.setup(self.BACK_DIRECTION_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        GPIO.add_event_detect(self.UP_DIRECTION_PIN, GPIO.BOTH, callback=self.UP_DIRECTION , bouncetime=200)
        GPIO.add_event_detect(self.DOWN_DIRECTION_PIN, GPIO.BOTH, callback=self.DOWN_DIRECTION, bouncetime=200)
        GPIO.add_event_detect(self.LEFT_DIRECTION_PIN, GPIO.BOTH, callback=self.LEFT_DIRECTION, bouncetime=200)
        GPIO.add_event_detect(self.RIGHT_DIRECTION_PIN, GPIO.BOTH, callback=self.RIGHT_DIRECTION , bouncetime=200)
        GPIO.add_event_detect(self.FORWARD_DIRECTION_PIN, GPIO.BOTH, callback=self.FORWARD_DIRECTION, bouncetime=200)
        GPIO.add_event_detect(self.BACK_DIRECTION_PIN, GPIO.BOTH, callback=self.BACK_DIRECTION, bouncetime=200)

    def UP_DIRECTION(self):
        if GPIO.input(self.UP_DIRECTION_PIN) == GPIO.LOW:
            self.ZP_AXIS_MOTORS.move()
        else:
            self.ZP_AXIS_MOTORS.stop()
    
    def DOWN_DIRECTION(self):
        if GPIO.input(self.DOWN_DIRECTION_PIN) == GPIO.LOW:
            self.ZN_AXIS_MOTORS.move()
        else:
            self.ZN_AXIS_MOTORS.stop()

    def LEFT_DIRECTION(self):
        if GPIO.input(self.LEFT_DIRECTION_PIN) == GPIO.LOW:
            self.XN_AXIS_MOTORS.move()
        else:
            self.XN_AXIS_MOTORS.stop()
            
    def RIGHT_DIRECTION(self):
        if GPIO.input(self.RIGHT_DIRECTION_PIN) == GPIO.LOW:
            self.XP_AXIS_MOTORS.move()
        else:
            self.XP_AXIS_MOTORS.stop()
            
    def FORWARD_DIRECTION(self):
        if GPIO.input(self.FORWARD_DIRECTION_PIN) == GPIO.LOW:
            self.YN_AXIS_MOTORS.move()
        else:
            self.YN_AXIS_MOTORS.stop()

    def BACK_DIRECTION(self):
        if GPIO.input(self.BACK_DIRECTION_PIN) == GPIO.LOW:
            self.YP_AXIS_MOTORS.move()
        else:
            self.YP_AXIS_MOTORS.stop()

def main():
    print("Press the button to start the motor.")
    motor_system = MotorSystem()
    try:
        while True:
            time.sleep(1)  # Wait for button press

    except KeyboardInterrupt:
        pass
    finally:
        motor_system.ZN_AXIS_MOTORS.stop()
        motor_system.XN_AXIS_MOTORS.stop()
        motor_system.YN_AXIS_MOTORS.stop()
        motor_system.ZP_AXIS_MOTORS.stop()
        motor_system.XP_AXIS_MOTORS.stop()
        motor_system.YP_AXIS_MOTORS.stop()

if __name__ == '__main__':
    GPIO.setmode(GPIO.BCM)
    main()
